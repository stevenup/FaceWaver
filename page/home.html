<ion-view class="page_home"  view-title="home"  hide-back-button="true" can-swipe-back="false" ng-click="reset_gyro()" style="    position: fixed; width: 100%; height: 100%; top: 0; left: 0;background: url(img/bg.jpg);background-size:cover;">

	<!-- <div class="logo" style="width:80%;margin:auto;margin-top: 90px;">
		<img src="img/logo.png" style="width: 100%;">
	</div>

	<a class="start" href="#/tab/upload" style="width:80%;margin:auto;margin-top: 90px;display: block;">
		<img src="img/start.png" style="width: 100%;">
	</a> -->


	<div class="loading" ng-if="!m.is_loaded" style="width: 100px;height: 100px;position: fixed;left: 0;right: 0;top:0;bottom:0;margin:auto;text-align: center;">
		<canvas vs-loading-progress="m.loading_progress" width="60" height="60" style="display: block;margin:auto;"></canvas>
		<div>LOADING...</div>
	</div>

	<div class="bg_wave" ng-show="m.is_loaded"></div>

	<div class="main" ng-show="m.is_loaded" style="pointer-events: none;">

		<div class="anim_head place_holder" style="">
			<img ng-src="img/anim_head/head_{{pad2(m.anim_head_index)}}.png" style="">
		</div>

		<div class="anim_head" ng-attr-style="
			transform:
				translateX({{m.gamma_result*1.6}}px) 
				translateY({{m.beta_result*1.0}}px);
		">
			<img ng-src="img/anim_head/head_{{pad2(m.anim_head_index)}}.png" style="">
		</div>

		<div class="anim_band" ng-attr-style="
			transform:
				translateX({{m.gamma_result*1.0}}px) 
				translateY({{m.beta_result*0.6}}px);
		">
			<img ng-src="img/anim_band/飘带_{{pad2(m.anim_band_index)}}.png" style="">
		</div>

		<div class="anim_logo" ng-attr-style="
			transform:
				translateX({{m.gamma_result*.5}}px) 
				translateY({{m.beta_result*.5}}px);
		">
			<img ng-src="img/anim_logo/标题_{{pad2(m.anim_logo_index)}}.png" style="">
		</div>

		<a class="start" href="#/tab/upload" ng-click="$event.stopPropagation()" style="pointer-events: all;">
			<img class="normal" src="img/home_satart2.png">
			<img class="pressed" src="img/home_satart.png">
		</a>
	</div>

	<div class="orientation" ng-if="false" style="position: fixed;background: white;top:0;left: 100px;height: 80px;width:100%;color:black;">
		<div>{{m.alpha}}</div>
		<div>{{m.beta}}</div>
		<div>{{m.gamma}}</div>
	</div>





	

	<!-- This is the 'compute shader' for the water heightmap: -->
	<script id="heightmapFragmentShader" type="x-shader/x-fragment">

		#include <common>

		uniform vec2 mousePos;
		uniform float mouseSize;
		uniform float viscosityConstant;

		#define deltaTime ( 1.0 / 60.0 )
		#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )

		void main()	{

			vec2 cellSize = 1.0 / resolution.xy;

			vec2 uv = gl_FragCoord.xy * cellSize;

			// heightmapValue.x == height
			// heightmapValue.y == velocity
			// heightmapValue.z, heightmapValue.w not used
			vec4 heightmapValue = texture2D( heightmap, uv );

			// Get neighbours
			vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
			vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
			vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
			vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );

			float sump = north.x + south.x + east.x + west.x - 4.0 * heightmapValue.x;

			float accel = sump * GRAVITY_CONSTANT;

			// Dynamics
			heightmapValue.y += accel;
			heightmapValue.x += heightmapValue.y * deltaTime;

			// Viscosity
			heightmapValue.x += sump * viscosityConstant;

			// Mouse influence
			float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
			heightmapValue.x += cos( mousePhase ) + 1.0;

			gl_FragColor = heightmapValue;

		}

	</script>

	<!-- This is just a smoothing 'compute shader' for using manually: -->
	<script id="smoothFragmentShader" type="x-shader/x-fragment">

		uniform sampler2D texture;

		void main()	{

			vec2 cellSize = 1.0 / resolution.xy;

			vec2 uv = gl_FragCoord.xy * cellSize;

			// Computes the mean of texel and 4 neighbours
			vec4 textureValue = texture2D( texture, uv );
			textureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );
			textureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );
			textureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );
			textureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );

			textureValue /= 5.0;

			gl_FragColor = textureValue;

		}

	</script>

	<!-- This is the water visualization shader, copied from the MeshPhongMaterial and modified: -->
	<script id="waterVertexShader" type="x-shader/x-vertex">

		uniform sampler2D heightmap;

		#define PHONG

		varying vec3 vViewPosition;

		#ifndef FLAT_SHADED

			varying vec3 vNormal;

		#endif

		#include <common>
		#include <uv_pars_vertex>
		#include <uv2_pars_vertex>
		#include <displacementmap_pars_vertex>
		#include <envmap_pars_vertex>
		#include <color_pars_vertex>
		#include <morphtarget_pars_vertex>
		#include <skinning_pars_vertex>
		#include <shadowmap_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		void main() {


			vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );

			#include <uv_vertex>
			#include <uv2_vertex>
			#include <color_vertex>

			// # include <beginnormal_vertex>
			// Compute normal from heightmap
			vec3 objectNormal = vec3(
				( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
				( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
				1.0 );
			//<beginnormal_vertex>

			#include <morphnormal_vertex>
			#include <skinbase_vertex>
			#include <skinnormal_vertex>
			#include <defaultnormal_vertex>

		#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

			vNormal = normalize( transformedNormal );

		#endif

			//# include <begin_vertex>
			float heightValue = texture2D( heightmap, uv ).x;
			vec3 transformed = vec3( position.x, position.y, heightValue );
			//<begin_vertex>

			#include <morphtarget_vertex>
			#include <skinning_vertex>
			#include <displacementmap_vertex>
			#include <project_vertex>
			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>

			vViewPosition = - mvPosition.xyz;
			gl_PointSize=10.0 * ( 300.0 / -mvPosition.z );

			#include <worldpos_vertex>
			#include <envmap_vertex>
			#include <shadowmap_vertex>

		}

	</script>
	<script type="x-shader/x-fragment" id="fragmentshader">

		uniform sampler2D texture;


		void main() {

			// gl_FragColor = vec4( color * vColor, 1.0 );

			gl_FragColor = vec4(0.0, .1, 0.0, 1.0) * texture2D( texture, gl_PointCoord );

			// if ( gl_FragColor.a < ALPHATEST ) discard;

		}
	</script>

</ion-view>
